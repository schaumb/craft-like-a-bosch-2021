<html lang="hu">
<head>
    <meta charset="UTF-8">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2"></script>
    <title>Our solution</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>

<script>
    var game = new Phaser.Game({
        type: Phaser.AUTO,
        scale: {
            mode: Phaser.Scale.RESIZE,
            width: "100%",
            height: "100%"
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        },
        physics: {
            default: 'matter',
            matter: {
                setBounds: true,
                gravity: false,
                debug: {
                    showBounds: true,
                    showVelocity: true,
                    showCollisions: true,
                    showSeparation: true,
                    showInternalEdges: true,
                    showConvexHulls: true
                }
            }
        }
    });

    let cursors;
    let car;
    let drags;
    let rotateObj;

    function genCircle(count, x, y, radius) {
        const res = []
        for (let i = 0; i < count; ++i) {
            const r = Math.PI * 2 * i / count;
            res.push({x: Math.sin(r) * radius + x, y: Math.cos(r) * radius + y})
        }
        return res
    }

    function makeDraggable(value) {
        value.setInteractive({
            cursor: 'grabbing'
        })
        value.on('wheel', function (pointer, deltaX, deltaY) {
            value.setScale(value.scale + deltaY * -0.001);
            // value.scale += deltaY * -0.001;
        });

        if (value.type === "Arc")
            this.matter.add.gameObject(value, {
                circleRadius: value.width / 2,
                vertices: genCircle(26, value.x, value.y, value.width / 2),
                isStatic: true
            });
        else
            this.matter.add.gameObject(value, {
                isStatic: true
            });
        value.body.maxSpeed = 0;

        this.input.setDraggable(value);
        drags.push(value)
    }

    function preload() {
        // this.load.image('key', 'path');
        this.load.image('carIMG', 'car.png');
    }

    function create() {

        cursors = this.input.keyboard.createCursorKeys();

        car = this.matter.add.image(400, 300, 'carIMG');
        car.setInteractive();
        drags = []

        makeDraggable.call(this, this.add.rectangle(20, 20, 20, 30, 0xffffff));
        makeDraggable.call(this, this.add.circle(50, 20, 20, 0xffffff));

        this.input.mouse.disableContextMenu();
        this.input.on('drag', function (pointer, gameObject, dragX, dragY) {
            gameObject.setPosition(dragX, dragY);
        });

        let lastTimeClick = {time: 0, objects: [], right: false};

        this.input.on("pointerup", function () {
            rotateObj = undefined;
        });
        this.input.on("pointerdown", function (pointer, gameObject) {
            const right = pointer.rightButtonDown();
            if (right) {
                gameObject.forEach(obj => {
                    if (obj.type === "Rectangle")
                        rotateObj = obj;
                });
            }
            let clickDelay = pointer.time - lastTimeClick.time;
            if (lastTimeClick.right === right && clickDelay < 200) {
                const set = new Set(lastTimeClick.objects);
                gameObject.filter(o => set.has(o)).forEach(v => {
                    if (right) {
                        const i = drags.indexOf(v);
                        if (i !== -1) {
                            delete drags[i];
                            v.destroy();
                        }
                    } else {
                        if (v.type === "Arc") {
                            makeDraggable.call(this.scene, this.scene.add.circle(v.x + 10, v.y + 10, v.radius * v.scale, 0xffffff))
                        } else if (v.type === "Rectangle") {
                            makeDraggable.call(this.scene, this.scene.add.rectangle(v.x + 10, v.y + 10, v.width * v.scaleX, v.height * v.scaleY, 0xffffff))
                        }
                    }
                }, this);
            } else {
                lastTimeClick = {
                    time: pointer.time,
                    objects: gameObject,
                    right: right
                };
            }
        })
        this.scale.on('resize', resize, this);
    }

    function resize(gameSize) {
        this.cameras.resize(gameSize.width, gameSize.height);
        this.matter.world.setBounds(0, 0, gameSize.width, gameSize.height);
    }

    function update() {
        car.setVelocity(0);

        if (cursors.left.isDown) {
            car.setVelocityX(-3);
        } else if (cursors.right.isDown) {
            car.setVelocityX(3);
        }

        if (cursors.up.isDown) {
            car.setVelocityY(-3);
        } else if (cursors.down.isDown) {
            car.setVelocityY(3);
        }

        if (rotateObj) {
            rotateObj.setAngle(rotateObj.angle + 2);
        }
    }
</script>
</body>
</html>
