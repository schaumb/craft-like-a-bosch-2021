<html lang="hu">
<head>
    <meta charset="UTF-8">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2"></script>
    <title>Our solution</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>

<script>
    new Phaser.Game({
        type: Phaser.AUTO,
        scale: {
            mode: Phaser.Scale.RESIZE,
            width: "100%",
            height: "100%"
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        },
        physics: {
            default: 'matter',
            matter: {
                setBounds: true,
                gravity: false,
                debug: {
                    showBounds: true,
                    showVelocity: true,
                    showCollisions: true,
                    showSeparation: true,
                    showInternalEdges: true,
                    showConvexHulls: true
                }
            }
        }
    });

    function genCircle(count, x, y, radius) {
        const res = []
        for (let i = 0; i < count; ++i) {
            const r = Math.PI * 2 * i / count;
            res.push({x: Math.sin(r) * radius + x, y: Math.cos(r) * radius + y})
        }
        return res
    }

    function makeDraggable(value) {
        value.setInteractive({
            cursor: 'grabbing'
        })
        value.on('wheel', function (pointer, deltaX, deltaY) {
            value.setScale(value.scale + deltaY * -0.001);
        });

        if (value.type === "Arc")
            this.matter.add.gameObject(value, {
                circleRadius: value.width / 2,
                vertices: genCircle(26, value.x, value.y, value.width / 2),
                isStatic: true
            });
        else
            this.matter.add.gameObject(value, {
                isStatic: true
            });
        value.body.maxSpeed = 0;

        this.input.setDraggable(value);
        this.drags.push(value)
    }

    function preload() {
        // this.load.image('key', 'path');
        this.load.image('carIMG', 'car.png');
    }

    function create() {
        this.makeDraggable = makeDraggable;
        this.cursors = this.input.keyboard.createCursorKeys();
        this.lastTimeClick = {time: 0, objects: [], right: false};
        this.drags = []

        const wheels = [this.add.rectangle(300, 220, 30, 20, 0x444444), this.add.rectangle(300, 380, 30, 20, 0x444444)];
        this.car = this.matter.add.image(400, 300, 'carIMG');
        this.car.setInteractive();
        this.car.carSpeed = 0;
        this.car.wheelRotation = 0;
        this.car.wheels = wheels;


        this.makeDraggable(this.add.rectangle(20, 20, 20, 30, 0xffffff));
        this.makeDraggable(this.add.circle(50, 20, 20, 0xffffff));

        this.input.mouse.disableContextMenu();
        this.input.on('drag', function (pointer, gameObject, dragX, dragY) {
            gameObject.setPosition(dragX, dragY);
        });
        this.input.on("pointerup", function () { this.scene.rotateObj = undefined; });
        this.input.on("pointerdown", function (pointer, gameObject) {
            const right = pointer.rightButtonDown();
            if (this.scene.lastTimeClick.right === right && pointer.time - this.scene.lastTimeClick.time < 200) {
                const set = new Set(this.scene.lastTimeClick.objects);
                gameObject.filter(o => set.has(o)).forEach(v => {
                    if (right) {
                        const i = this.scene.drags.indexOf(v);
                        if (i !== -1) {
                            delete this.scene.drags[i];
                            v.destroy();
                        }
                    } else {
                        if (v.type === "Arc") {
                            this.scene.makeDraggable(this.scene.add.circle(v.x + 10, v.y + 10, v.radius * v.scale, 0xffffff))
                        } else if (v.type === "Rectangle") {
                            this.scene.makeDraggable(this.scene.add.rectangle(v.x + 10, v.y + 10, v.width * v.scaleX, v.height * v.scaleY, 0xffffff))
                        }
                    }
                }, this);
            } else {
                if (right) {
                    gameObject.forEach(obj => {
                        if (obj.type === "Rectangle")
                            this.scene.rotateObj = obj;
                    });
                }
                this.scene.lastTimeClick = {
                    time: pointer.time,
                    objects: gameObject,
                    right: right
                };
            }
        })
        this.scale.on('resize', resize, this);
    }

    function resize(gameSize) {
        this.cameras.resize(gameSize.width, gameSize.height);
        this.matter.world.setBounds(0, 0, gameSize.width, gameSize.height);
    }

    function update() {
        const theCar = this.car;
        theCar.setVelocity(0);

        if (this.cursors.left.isDown && theCar.wheelRotation > -0.9) {
            theCar.wheelRotation -= 0.1;
        }

        if (this.cursors.right.isDown && theCar.wheelRotation < 0.9) {
            theCar.wheelRotation += 0.1;
        }

        if (!this.cursors.left.isDown && !this.cursors.right.isDown) {
            theCar.wheelRotation -= Math.sign(theCar.wheelRotation) * 0.025;
        }

        if (this.cursors.up.isDown && theCar.carSpeed < 1.0) {
            theCar.carSpeed += 0.01;
        } else if (this.cursors.down.isDown && theCar.carSpeed > -1.0) {
            theCar.carSpeed -= 0.01;
        }

        theCar.setAngularVelocity(theCar.wheelRotation * 0.005 * theCar.carSpeed*10)
        theCar.setVelocityX(-Math.cos(theCar.angle * Math.PI / 180 + theCar.body.angularVelocity / 0.1) * theCar.carSpeed*10);
        theCar.setVelocityY(-Math.sin(theCar.angle * Math.PI / 180 + theCar.body.angularVelocity / 0.1) * theCar.carSpeed*10);

        theCar.wheels.forEach(v => v.setAngle(theCar.wheelRotation / Math.PI * 180 ))

        if (this.rotateObj) {
            this.rotateObj.setAngle(this.rotateObj.angle + 1);
        }
    }
</script>
</body>
</html>
